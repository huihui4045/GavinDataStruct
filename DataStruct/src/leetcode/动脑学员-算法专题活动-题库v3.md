-----------------------------------------------------------------

- 添加了几道图论题目

2017年11月30日

- 修正了83号题目

2017年11月29日

-----------------------------------------------------------------

动脑学院算法专题活动 - 面试类算法题库

-----------------------------------------------------------------
  类别目录
-----------------------------------------------------------------
1. 数组
2. 链表
3. 栈
4. 优先队列
5. 二叉树
6. 递归回溯
7. 动态规划
8. 贪心算法
9. 图论

说明 ：
由于某些数据结构或算法思想（如队列和递归）通常需要配合其他数据结构一起使用，
因此它们可能包含一些其他类别的题目中。


-----------------------------------------------------------------
题目（类别 - 题目名 - 难度 - LeetCode题号）：
-----------------------------------------------------------------

----- 数 组 -----

-----------------------------------------------------------------

数组01 - 0的移动 - 简单 - 283

给定一个数组nums，写一个函数，将数组内的0移动到数组末尾，并保持其他非零元素在原数组中的相对位置不变。
比如，给定nums = [0, 1, 0, 3, 12]，调用你的函数之后，nums应该变成[1, 3, 12, 0, 0]。

注意：
1. 请直接在传入的数组对象上修改，而不是另外创建一份拷贝（术语叫做 in-place，也有中译为“原地”）。
2. 尽量减少操作指令代码的行数。

-----------------------------------------------------------------

数组02 - 删除元素 - 简单 - 27

给定一个数组和一个值，原地移除数组中所有给定的值，并返回新数组的长度。
不允许申请额外空间，确保空间复杂度为O(1)。
数组中的元素可以被改变，不用考虑超出新长度之后的空间遗留。

比如：
给定nums = [3, 2, ,2 3]， val = 3，
你的函数应该返回length = 2， nums = [2, 2]。

-----------------------------------------------------------------

数组03 - 从有序数组中删除重复元素 - 简单 - 26

给定一个有序数组，原地删除重复元素使得数组中的元素只保留一个，并且返回新长度。
禁止申请额外空间，确保空间复杂度为O(1)。

比如：
给定nums = [1, 1, 2]，

你的函数应该返回length = 2，nums = [1, 2]。
不用考虑超出新长度之后的空间遗留。

-----------------------------------------------------------------

数组04 - 从有序数组中删除重复元素2 - 中等 - 80

与数组03题条件相同，但是变更一个要求：可以允许元素最多重复2次。

比如，给定nums = [1, 1, 1, 2, 2, 3]，
返回length = 5， nums = [1, 1, 2, 2, 3]。同样不用考虑超出新长度之后的空间遗留。

-----------------------------------------------------------------

数组05 - 两数的和（输入数组已排序） - 简单 - 167

【题中包含的数组的进阶技术：对撞指针技术】

给定一个整形数组，并且数组内元素已经按升序排列，找出两个元素，使得它们之和与给定的数相等。

函数应该返回找到的这两个元素的索引，并且第一个元素的索引小于等于第二个元素的索引，并且元素索引起始位置是基于1而不是基于0。

你可以假设给定的目标数在数组中必定找得到对应的两个元素。

比如：
输入： numbers = [2, 7, 11, 15], target = 9
输出： index = 1, index = 2

-----------------------------------------------------------------

数组06 - 装最多的水 - 中等 - 11

【题中包含的数组的进阶技术：对撞指针技术】

给出一个非负整数 a1, a2, ..., an,它们分别代表x轴上的一个点(i, ai)，在每个点上画高度为ai的“墙”，
用来代表容器。选择两堵墙，使得它们和x轴围起来的容器装水容量最大。

注意：给出的n>=2。

-----------------------------------------------------------------

数组07 - 排序颜色 - 中等 - 75

【题中包含的数组的进阶技术：对撞指针、三路快速排序】

给定一个数组，其中有n个元素，分别为红色、白色和蓝色，请将数组中的元素进行排序，使得颜色相同的元素排在一起，并且颜色顺序为红、白、蓝。
我们使用整数0、1、2分别代表红、白、蓝3种颜色。

注意：禁止使用标准库提供的排序算法。
提示：尝试使用三路快速排序的思路以O(n)的时间复杂度解决问题。

-----------------------------------------------------------------

数组08 - 找到数组中第k大的元素 - 中等 - 215

【题中包含的数组的进阶技术：对撞指针、快速排序】

在一个无序数组中找到第k大的元素。注意这里的第k大是指在排序顺序中第k大的元素，而不是第k个不同的元素。

比如：
给定[3, 2, 1, 5, 6, 4]，k = 2，则应该返回5。

注意：
你可以假设k的值是有效的。

提示：
使用快速排序的思想可以以O(n)的时间复杂度解决该问题。

-----------------------------------------------------------------

数组09 - 最小尺寸子数组之和 - 中等 - 209

【题中包含的数组的进阶技术：滑动窗口技术】

给定一个整形数组和一个数组s，找出数组中最短的一个连续子数组，使得连续子数组中的元素之和sum>=s。
返回这个最短连续子数组。

比如：
nums = [2, 3, 1, 2, 4, 3], s = 7
答案为[4, 3]

-----------------------------------------------------------------

数组10 - 没有重复字符的最长子串 - 中等 - 3

【题中包含的数组的进阶技术：滑动窗口技术】

在一个字符串中寻找没有重复字母的最长子串

比如：
“abcabcbb”,结果为“abc”
“bbbbbb”，结果为“b”
“pwwkew”，结果为“wke”

-----------------------------------------------------------------

数组11 - 最小窗口子串 - 困难 - 76

给定一个字符串S和字符串T，在S中寻找最短的子串，包含T中所有的字符。

比如：
S=“ADOBECODEBAXC”，T=“ABC”
结果为“BAXC”。

----- 链 表 -----

辅助数据结构：
```C++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x): val(x), next(NULL) {}
};
```

```java

public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

```

链表01 - 进阶反转链表 - 中等 - 92

反转一个链表中从m到n的元素。

比如：对于一个链表1->2->3->4->5->NULL，m = 2， n = 4
则返回链表 1->4->3->2->5->NULL

注意：可以假设1<=m<=n<=链表长度。

-----------------------------------------------------------------

链表02 - 成对交换链表节点 - 中等 - 24

给定一个链表，为每两个相邻节点做一次交换给定一个链表，为每两个相邻节点做一次交换。
要求不能修改节点的值，只能修改链表结构。要求O(1)的空间复杂度。

比如：1->2->3->4，应该返回2->1->4->3。

-----------------------------------------------------------------

链表03 - 链表相加低阶 - 中等 - 2

给定两个非空链表，分别代表两个非负整数。链表中的数字以逆序排列并且每个节点只包含一个个位数。
将两个链表所代表的数字相加并且以链表的形式返回这个和。

比如：输入2->4->3和5->6->4
应该返回 7->0->8

-----------------------------------------------------------------

链表04 - 链表相加高阶 - 中等 - 2

【题中包含的进阶技术：设计数据结构】

给定两个非空链表，分别代表两个非负整数。这次链表中的数字以顺序排列，同样每个链表包含一个个位数字。
计算两个链表所代表的数字的和，并以链表的形式返回这个和。

你可以假设给定的输入不会包含为0的开头，除非这个链表代表的数字本身就是0。

比如：
给定7->2->4->3和5->6->4，
输出7->8->0->7

提示：
如果我们要求不可以修改给出的链表呢？也就是说，先反转链表再利用链表02的解，这个做法是不被允许的。
提示也许可以创建一种数据结构来解决这个问题。

-----------------------------------------------------------------

链表05 - 删除链表元素 - 简单 - 203

【题中包含的进阶技术：虚拟头结点】

删除链表中值为val的元素。

比如：
给出: 1->2->6->3->4->5->6，val = 6
返回: 1->2->3->4->5

-----------------------------------------------------------------

链表06 - 从有序链表中删除重复元素 - 简单 - 83

【题中包含的进阶技术：虚拟头结点】

给定一个有序链表，删除其中所有重复的元素，只留下不存在重复的元素。

比如：
给出1->2->3->3->4->4->5，返回1->2->5，
给定1->1->2->3->3 返回 1->2->3


-----------------------------------------------------------------

链表07 - 从链表中删除倒数第N个元素 - 中等 - 19

【题中包含的进阶技术：双指针技术】

给定一个链表，删除其倒数第N个元素并返回头结点。

比如：

给定： 1->2->3->4->5， n = 2，
则应该返回 1->2->3->5。

注意：
n为有效值。

提示：使用双指针技术来实现只用一次遍历求解。

-----------------------------------------------------------------

链表08 - 旋转链表 - 中等 - 61

【题中包含的进阶技术：双指针技术】

给定一个链表，让链表向右旋转k位，其中k为非负数。

比如: 1->2->3->4->5->NULL，k = 2
返回: 4->5->1->2->3->NULL。

-----------------------------------------------------------------

链表09 - 重排链表 - 难 - 143

【题中包含的进阶技术：双指针技术】

给定一个链表L: L0→L1→…→Ln-1→Ln,将其重排序为 L0→Ln→L1→Ln-1→L2→Ln-2→…

注意：
原地排序，并且请思考如何只用一次遍历求解。

比如：
1->2->3->4，返回1->4->2->3。

-----------------------------------------------------------------

栈01 - 括号配对 - 简单 - 20

给定一个字符串，其中只包含()，[]，{},判定字符串中的括号匹配是否合法。

比如 “()”，“()[]{}”是合法的，“(}”，“([)]”是非法的。

-----------------------------------------------------------------

栈02 - 逆波兰表达式求值 - 中等 - 150

给定一个数组，表示一个逆波兰表达式，求其值。

运算类型只有+、-、*、/。

比如：
["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

-----------------------------------------------------------------

栈03 - 简化路径 - 中等 - 71

给定一个Unix风格的绝对路径，进行简化。

比如：
path = "/home/" => "/home"
path = "/a/./b/../../c/" => "/c"

注意：
考虑一些边界条件： 
1. 对于path = "/../" 可以返回"/"；
2. 路径中可能存在的连续'/'，比如"/home//foo"，这种情况下应该忽略重复的斜杠并返回"/home/foo"。

栈04 - 嵌套列表平滑迭代器 - 中等 - 341

给定一个整形的嵌套列表，实现一个迭代器来使对它的遍历平滑化。

其中列表中的元素可能是一个整形元素，也可能是一个列表 —— 这个列表同样也可能同时包含整形元素或另一个子列表。

比如：
给定一个列表[[1,1],2,[1,1]]，
连续调用迭代器的next方法，直到hasNext返回false，则遍历的元素依次为[1,1,2,1,1]。

给定一个列表[1,[4,[6]]]，
同样，遍历结果应该为[1,4,6]。

（题目中已经给出了嵌套列表这个数据结构的接口的定义，请自行查看）

-----------------------------------------------------------------
*****************************************************************
由于队列的一个重要的作用，就是实现广度优先算法，因此队列经常用来解决树和图中的相关问题。
所以，我们将会在树和图的相关问题中，尝试用队列这种数据结构解决问题。
因此我们可以看到队列一般是与其他数据结构结合使用。大家可以回忆一下，这一点的另一个体现， 
也就是优先队列。
*****************************************************************

优先队列01 - 出现频率第k的元素 - 中等 - 347

给定一个非空整形数组，返回出现频率第k的元素。

比如：
给定[1,1,1,2,2,3]，k=2，返回[1,2]。

注意：
* 你可以假设k为有效的值，1 <= k <= 独一元素数量
* 算法时间复杂度必须至少为O(nlogn)。

提示：这里提供三个思路：

1. 扫描一遍统计频率；排序找到前k个出现频率最高的元素 O(nlogn)；
2. 维护优先队列，O(nlogk)
3. 维护优先队列，时间复杂度为(Onlog(n-k))

-----------------------------------------------------------------

优先队列02（链表） - 合并k个有序链表 - 困难 - 23

合并k个有序的链表并返回合成的有序列表。

提示：当k为2时，其实就是经典的归并排序中的归并过程。当这个问题解决后，
我们就自然可以设计出k分归并排序算法了。

-----------------------------------------------------------------
树和递归

大家知道，树这种数据结构中最经典的应用自当是二叉树。二叉树具备天然的递归结构，因此，
二叉树相关的大部分题目当中，都可以运用递归这种思想解决问题。

这里简单地谈一谈如何设计一个递归算法：
你需要深刻地认识“递”和“归”这两个字，“递”意味着传递，因此在设计时，你要明白你的代码如何传递到
所有子问题；“归”意味着边界条件，递归程序必须在适当的时候返回，如何考虑返回条件，来达成最终的结果，
掌握这两个字，就能更加深入地理解递归这个思想的精髓。

------------------------------------------------------------------

二叉树01（队列） - 二叉树的层序遍历 - 中等 - 102

给定一个二叉树，返回其层序遍历结构（从左往右，一层一层地遍历）。

比如： 给定二叉树 [3, 9 , 20 , null, null, 15, 7]，
    3
   / \
  9  20
    /  \
   15   7
返回的结果应该是：
[
    [3],
    [9, 20],
    [15, 7]
]

-----------------------------------------------------------------


二叉树02（队列） - 从右侧观察二叉树的结果 - 中等 - 199

给定一棵二叉树，相信你站在树的右边观察它，返回你能看到的结点，顺序为自上而下：

比如：
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
应该返回[1, 3, 4]

-----------------------------------------------------------------

二叉树03 - 二叉树最低深度 - 简单 - 111

求一棵二叉树的最低深度，也就是从根节点到叶子结点的最短路径的长度。

二叉树04 - 反转二叉树 - 简单 - 226

这个题目大有来头~当年homebrew的作者去面试Google，就是因为这道基础题做不出来被pass掉了，这在业界曾经引起了广泛的反响。

Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.

反转二叉树。
原树：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
反转后：
     4
   /   \
  7     2
 / \   / \
9   6 3   1

-----------------------------------------------------------------

二叉树05 - 判断二叉树是否对称 - 简单 - 101

给定一棵二叉树，检查它是否为对称的。

比如：
    1
   / \
  2   2
 / \ / \
3  4 4  3
是一棵对称的二叉树，而
    1
   / \
  2   2
   \   \
   3    3
则为非对称。

注意：
尝试用递归和迭代两种方式解决。

-----------------------------------------------------------------

二叉树06 - 计算完全二叉树的节点个数 - 中等 - 222

给定一个完全二叉树，求它的节点个数。

概念：
完全二叉树： 除了最后一层，其他所有层的节点数达到最大，同时最后一层的所有节点都在最左侧。

满二叉树： 所有节点数达到最大。

-----------------------------------------------------------------

二叉树07 - 判断一棵二叉树是否为平衡二叉树 - 简单 - 110 

判断一棵二叉树是否为平衡二叉树。

平衡二叉树： 每一个节点的左右子树的高度差不超过1。

-----------------------------------------------------------------

二叉树08 - 路径和 - 简单 - 112

给出一棵二叉树以及一个数字sum，判断在这棵二叉树上是否存在一条从根节点到叶子的路径，
其路径上的所有节点和为sum。

技巧：如何在递归过程中保存数据。

比如：
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
如果sum = 22，则可以找到这条路径满足条件： 5->4->11->2。

-----------------------------------------------------------------

二叉树09 - 左叶子的和 - 简单 - 404

找到树中所有左叶子的和。

比如：
    3
   / \
  9  20
    /  \
   15   7
这棵树中有两个左叶子，9和15，因此返回结果应该为24。

-----------------------------------------------------------------

二叉树10 - 二叉树路径 - 简单 - 257

给定一棵二叉树，返回所有表示从根节点到叶子结点路径的字符串。

技巧：如何利用递归函数的返回值。

如：
   1
 /   \
2     3
 \
  5
返回结果为：
["1->2->5", "1->3"]

-----------------------------------------------------------------

二叉树11 - 根节点到叶子结点的和 - 简单 -  129

给定一棵二叉树，每个节点都是一个0-9的数字。从根节点到叶子结点的每条路径可以表示成一个数，
求这些数的和。

比如：
    1
   / \
  2   3
  
1->2，可以表示成12；
1->3，可以表示成13；
所以结果为12+13=25。

-----------------------------------------------------------------

二叉树12 - 路径和3 - 简单 - 437

技巧：更加复杂的递归逻辑。

给出一棵二叉树以及一个数字sum，判断二叉树上存在多少条路径，使其路径上的所有节点的和为sum。

注意：
* 其中路径不一定要起始于根节点、终止于叶子结点。
* 路径虽然可以从任意节点开始，但只能往下走。

-----------------------------------------------------------------

二叉树13（二分搜索树） - 二叉搜索树中的最近公共祖先 - 简单 - 235

给定一棵二叉搜索树和两个节点，寻找这两个节点的最近公共祖先。

比如：
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
         
给定2和8，则结果为6。给定2和4则结果为2。

-----------------------------------------------------------------

二叉树14（二分搜索树） - 在二分搜索树中删除一个节点 - 中等 - 450

给定一个二分搜索树，删除其中一个节点。

一般来说，删除操作可以分为两个不走：
1. 查找到要删除的那个节点
2. 如果找到，则删除它。

注意：
时间复杂度至少得小于等于O(树的高度)

比如：

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定要删除的节点为3。
其中一个可行的答案为[5,4,6,2,null,null,7]，如下：

    5
   / \
  4   6
 /     \
2       7

另一种有效的答案为 [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
    
-----------------------------------------------------------------

二叉树15（二分搜索树） - 将有序数组转换为一颗平衡的二叉搜索树 - 简单 - 108

给定一个有序数组，生成一棵平衡的二叉搜索树。

-----------------------------------------------------------------
-----------------------------------------------------------------

递归和回溯

之前的递归算法问题都是建立在二叉树上的，那么在更广义的范围内运用递归呢？

在递归问题中一个经典的思想就是回溯法，而它们适用的问题一般都是树形问题。

实际上回溯法是一个很经典的思想，其核心在于搜索，它也是古典人工智能的基础。
我们经常听说的8皇后问题、数独，都可以采用回溯法来解决。

-----------------------------------------------------------------

递归回溯01 - 9宫格键盘中的字母组合 - 中等 - 17

给定一个数字字符串，返回这些数字能在手机的9宫格键盘中组合成的所有字母组合。

比如：

给出“23”，则可以组合成：
["ab","ae","af","bd","be","bf","cd","ce","cf"]。

-----------------------------------------------------------------

递归回溯02（排列问题） - 排列 - 中等 - 46

给定一个数字素组，返回它们所有可能的排列。

比如：
[1,2,3]，则结果为：
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

-----------------------------------------------------------------

递归回溯02（排列问题）- 排列2 - 中等 - 47

给定一个整形数组，其中可能有相同的元素，返回这些元素所有排列的可能（不重复）。

比如给出[1,1,2]，则结果为：
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

-----------------------------------------------------------------

递归回溯03（组合问题） - 组合 - 中等 - 77

给定两个整数n和k，求在1...n这n个数字中选出k个数字的所有组合。

比如n = 4, k = 2，
则结果为：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

提示：采用“剪枝”思想尝试进行优化。

-----------------------------------------------------------------

递归回溯04（组合问题） - 组合之和 - 中等 - 39

给定一个结合，其中所有元素各不相同，给定一个数组T。寻找该集合中，所有能使得元素和为T的组合。（集合中元素可以多次使用）

如给定集合nums = [2,3,6,7],T=7，
返回[[7],[2,2,3]]

-----------------------------------------------------------------

递归回溯05（二维平面上的回溯） - 单词搜索 - 中等 - 79

给定一个2D屏幕和一个单词，寻找单词是否在这个网格中。

单词可以从每个相邻格子中的字母组合而成，这个相邻只能是水平或者竖直方向的。

比如给定：

board = 
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

单词 = "ABCCED", -> 返回 true,
单词 = "SEE",    -> 返回 true,
单词 = "ABCB",   -> 返回 false.

-----------------------------------------------------------------

递归回溯06（floodfill算法） - 岛屿数量 - 中等 - 200

给定一个二维数组，“1”表示陆地，“0”表示水。横向或纵向的陆地形成岛屿，被水域分开。问给出的地图中有多少个岛屿。

比如:
11110
11010
11000
00000
有1个岛屿，

11000
11000
00100
00011

有3个岛屿。

-----------------------------------------------------------------

递归回溯07 - n皇后问题 - 困难 - 51

求n皇后问题的所有解。

n个皇后摆放在n*n的棋盘格中，使得横竖和两个对角线方向均不会同时出现两个皇后。

比如下面有两个4皇后问题的解：

[
 [".Q..",  // 解1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解2
  "Q...",
  "...Q",
  ".Q.."]
]

-----------------------------------------------------------------

递归回溯08 - 求解数独 - 困难 - 37

设计一个算法求解数独。

空的格子用"."表示。可以假设每个给定的题目只有一个解。

-----------------------------------------------------------------
-----------------------------------------------------------------

动态规划

我们的题目会由易到难，一步一步见识越来越复杂的动态规划算法。

其实大多数动态规划问题，其本质都是一个递归的问题。如果你用动态规划暂时无法解决一个问题，可以先试试用递归的思想，
解出来之后，再把它改造成动态规划。

实际上很多可以用动态规划解决的问题，都存在这些转换。
递归->记忆化搜索->动态规划

其实，简单来说，递归是自上而下，而动态规划则是自下而上。
在递归时，我们可以采用一种叫做记忆化搜索的技术，把重复计算的一些结果保存下来以避免重复计算。
经典的运用就是斐波那契数列算法，如果使用纯递归，在n比较大的时候就会很慢。用记忆化搜索的方法，
每计算几步就把结果保存下来，这样就可以剪去很多重复计算。

也就是说从递归中我们可以发现很多重叠的子问题，
把这些重叠解决之后，就可以转换成相应的记忆化搜索或者动态规划的解法。

从记忆化搜索到动态规划，要做的仅仅就是把自上而下的计算改成自下而上的。

-----------------------------------------------------------------

动态规划01 - 爬楼梯 - 简单 - 70

这个题目实际上是面试中常见的经典智力题（面试毒瘤）。你应该听过这样一个问题，
有10个台阶，每次你只能上一层或者两层，问一共有多少种上法。

这里我们把10改成n，请设计算法求解。实际上，它是一个经典的动态规划问题。


提示：如我们上面说到的，大多数动态规划的题目都可以用递归和记忆化搜索的方法解，
所以有时间的话请尽量尝试不同的方法，以加深理解。

-----------------------------------------------------------------

动态规划02 - 三角形 - 中等 - 120

给定一个三角形，找出自顶到底的最小和，每次你只能在下层最邻近的左右两个数之间移动。

比如：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

这个三角的最小和为2+3+5+1=11。

-----------------------------------------------------------------

动态规划03 - 矩阵最小路径 - 中等 - 64

给定一个m x n 的矩阵，矩阵内元素为非负数，找到一条自左上到右下的路径，使得经过的和最小。

注意：
你只能选择向下或者向右移动。

比如：
[[1,3,1],
 [1,5,1],
 [4,2,1]]
 
 返回结果为7，路径是1->3->1->1。
 
 -----------------------------------------------------------------
 
 动态规划04 - 分解整数 - 中等 - 343
 
 给定一个正整数n，将它分解成至少两个正整数，并且使得分解出的正整数的乘积最大。
 算法返回这个最大乘积。
 
 比如给定n=2，返回1（2=1+1）。给定n=10，返回36（10=3+3+4）。
可以假设n大于等于2且小于58。

-----------------------------------------------------------------

动态规划05 - 完全平方数 - 中等 -279

给出一个正整数n，寻找最少的完全平方数，使得它们的和为n。

比如：
12 = 4+4+4
13 = 4 + 9

-----------------------------------------------------------------

动态规划06 - 寻路 - 中等 - 65

给定一个二维数组，其中1代表障碍物，0代表通路。
从左上角出发，每次只能向下或向右，不能通过障碍。
问一共有多少种走法。

比如：
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
一共有2种。

可以假设m和n均不超过100。

-----------------------------------------------------------------

动态规划07 - 入室行窃 - 简单 - 198

你是一个专业的小偷，打算洗劫一条街的所有房子。每个房子里都有不同价值的财物。但是，如果你选择偷窃相邻的两栋房子，则会出发报警系统。编程求出你最多可以安全的偷窃多少价值的财物。

比如：
[3,4,1,2]，则返回6[3,(4),1,(2)]，前面是每栋房子的财物值，括号内是我们选择偷窃的房子。
[4,3,1,2]，则返回6[(4),3,1,(2)]。

-----------------------------------------------------------------

动态规划08 - 入室行窃2 - 中等 - 213

和上面的题类似，只不过这次街道是环形的，数组中第一个房子和最后一个房子为相邻的。

-----------------------------------------------------------------

动态规划09 - 股票交易 - 中等 - 309

给定一个数组，表示一支股票在每一天的价格。设计一个交易算法，在这些天进行自动交易，
要求：每天只能进行一次操作；卖完股票后，必须卖出才能再次买入；每次卖出股票后，
下一天是不能买入的。问如何交易才能使利益最大化？

如prices = [1,2,3,0,2]，最佳交易方式为：[buy, sell, cooldown, buy, sell],利润为3。

-----------------------------------------------------------------

动态规划10 - 0-1背包问题 - 非leetcode问题，请自行搜索

有一个背包，容量为C，现在有n种不同的物品，编号为0...n-1，其中每一件物品的重量为w(i)，
价值为v(i)。问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品总价值最大。

背包问题是动态规划的经典问题，掌握它对于理解动态规划这个算法有重大意义，希望学员们都做一下。
并且，请查阅相关的优化手段，因为这些优化思想是很通用的。

-----------------------------------------------------------------

动态规划11(背包问题变种) - 分割子集和相等 - 中等 - 416

给定一个非空数组，其中所有的数字都是正整数。问是否可以将这个数组的元素分成两部分，使得每部分的数字和相等？

如对[1,5,11,5]，可以分成[1,5,5]和[11]两部分，元素和相等，返回true。
如对[1,2,3,5]，无法分成元素和相等的两部分，返回false。

-----------------------------------------------------------------

动态规划12（背包问题变种） - 单词分解 - 中等 - 139

给定一个非空字符串s和一个字符串数组wordDict，问能否使用wordDict中的不同字符串首尾相接，组成s。假定wordDict中没有重复的字符串。

如s="leetcode"，dict=["leet","code"]，则返回true。

-----------------------------------------------------------------

动态规划13(背包问题变种) - 目标和 - 中等 - 494

给定一个非0数字序列，在这些数字前加上+或者-的符号，使其计算结果为给定的整数S。
问一共有多少种可能。

如：nums = [1,1,1,1,1]，S=3
答案为5。

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

-----------------------------------------------------------------

动态规划14（LIS问题） - 最长上升子序列 - 中等 - 300

给定一个整数序列，求其中的最长上升子序列的长度。

如[10, 9, 2, 5, 3, 7, 101, 18]，期最长上升子序列的长度为4。

最长上升子序列为[2,5,7,101]

-----------------------------------------------------------------

动态规划15(LCS问题) - 最长公共子序列 - 非leetcode

（面试毒瘤，请务必解决。）

给出两个字符串S1和S2，求着两个字符串的最长公共子序列的长度。

比如：
S1=AA[ACC]G[T]G[AG]T[TA]TT[C]G[TT]C[T]A[G]AA
S2=C[A]CC[CCTA]AG[GTAC]C[TTTG]GTTC
方括号内为两个字符串的公共子序列。

-----------------------------------------------------------------
-----------------------------------------------------------------
贪心算法


贪心算法01 - 分蛋糕 - 简单 - 455

假设你想给小朋友们分蛋糕。每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，
称为g(i)，g(i)表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小指s(i)。
如果s(j) >= g(i)， 我们将饼干j分给小朋友i之后，小朋友就会很高兴。给定数组s和g，问
如何分配饼干，能让更多的小朋友开心。

-----------------------------------------------------------------

贪心算法02 - 是否是子序列 - 中等 - 392

给定一个字符串s和t，检查s是否是t的子串。

你可以假设所有字符串都是小写字母组成，并且字符串t大小很长（大约500,000)个字符，
而s较短（小于100）。

注意通过下面的例子正确理解什么是子序列：
如s="abc",t="ahbgdc"，则为true；
如s="axc",t="ahbgdc"，则为false。

-----------------------------------------------------------------

贪心算法03 - 非重叠区间 - 中等 - 435

给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。

* 给定区间的起始点永远小于终止点
* [1,2]和[2,3]这种不叫重叠。

如[[1,2],[2,3],[3,4],[1,3]]，算法返回1，因为要删除[1,3]这个区间。
如[[1,2,[1,2],[1,2]]]，返回2。

（注意通过这个问题体会贪心算法和动态规划的区别。
一些动态规划的问题可以使用贪心算法解决，但它们必须满足一个性质，“贪心选择性质”，有兴趣可以查阅相关资料）



-----------------------------------------------------------------
-----------------------------------------------------------------

图论

图论为什么可以自成一系？其中一个原因是很多看似与图论不相关的问题实际上都可以建模成图论的问题。

-----------------------------------------------------------------

图论01（最短路径，队列） - 完全平方树 - 中等 - 279

（还记得吗，我们在动态规划中遇到过这个题。这也说明，一个问题的解法可以是多种多样的）

给定一个正整数n，寻找最少的完全平方数（1,4,9,16...），使它们的和为n。

比如给出n = 12，返回3，因为12 = 4 + 4 + 4；给出n = 13，返回2，因为13 = 4 + 9。

提示： 贪心法能解决这个问题吗？

-----------------------------------------------------------------

图论02(最短路径，队列) - 单词阶梯 - 中等 - 127

给定两个单词（beginWord和endWord），和一个单词字典，寻找一挑从beginWord到endWord的最短变换路径。
规则是每次变换只能改变一个字母，并且要存在于单词列表中。

比如beginWord = "hit"， endWord = "cog"，
单词列表为["hot", "dot", "dog", "lot", "log", "cog“],
我们可以找到的最短的变换路径为：
"hit"->"hot"->"dot"->"dog"->"cog"，
结果为5。

注意：
* 如果没有这样的变换序列则返回0
* 所有单词的长度相同
* 单词表中只有小写字母
* 可以假设单词表中没有重复单词
* 利用检查beginWord和endWord不为空字符串并且互不相同。

-----------------------------------------------------------------

图论03（最短路径，队列） - 单词阶梯2 - 中等 -126

题目和图论02相似，只不过这次我们需要找到所有可能的变换路径。

-----------------------------------------------------------------

图论04 - 职员重要度 - 简单 - 690

给出职员(employee)信息结构体，其中包括职员id，职员重要度(importance value)和他所有的**直接**下属们的id。

比如，职员1是职员2的领导，职员2是职员3的领导。他们的重要度分别为15、10和5。
职员1的数据结构可以表示为[1,15,[2]]，职员2可以表示为[2,10,[3]]，职员3可以表示为[3,5,[]]。
注意职员3也是职员1的下属，只不过不是直接下属。

现在给出一家公司内的职员信息，和一个其中职员的id。你要做的是返回这个职员以及他所有下属的重要度之和。

比如：
Input: [[1,5,[2,3]], [2,3,[]], [3,3,[]]],1
Output: 11

注意：
1.每个职员最多有一个直接领导。
2.这家公司的员工总数不超过2000人。

-----------------------------------------------------------------
图论05 - 0 1矩阵 - 中等 - 542

给出一个由0和1组成的矩阵，找出矩阵中每个小格中，离它最近的0的距离。

两个格子之间的距离为1。

比如举两个例子：

输入          输出
0 0 0       0 0 0
0 1 0       0 1 0
0 0 0       0 0 0
------------------
0 0 0       0 0 0
0 1 0       0 1 0
1 1 1       1 2 1

注意：
1. 矩阵的元素最多不超过10000个。
2. 给定的矩阵中至少有一个0。
3. 相邻格子只能是上下左右四个方向的。

-----------------------------------------------------------------
图论06 - 拷贝图 - 中等 - 133

拷贝无向图。图中的节点包含一个`label`(标签)和它的`neighbors`(相连节点)列表。

**无向图的OJ序列化表示法：**
节点具有唯一的标签。
使用`#`来分割每个节点，使用`,`来分割标签和相连节点列表。

比如一个序列：`{0,1,2#1,2#2,2}`
这个序列表示的图共有3个节点，因为可以看到`#`把它分割了成3个部分。
1. 第一个节点的标签为`0`，与它相连的节点的标签为`1`和`2`。
2. 第一个节点标签为1，与`2`相连。
3. 第三个节点标签为3，余它自身相连，意味着这条边是自环边(self-cycle)。

最后，这个图看起来是这样的：

```
       1
      / \
     /   \
    0 --- 2
         / \
         \_/
```

-----------------------------------------------------------------